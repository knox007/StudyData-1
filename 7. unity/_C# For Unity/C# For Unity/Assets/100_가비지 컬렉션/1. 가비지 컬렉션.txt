/// 가비지 컬렉션 ////////////////////////////////////////////////////////////
--------------------
1.	가비지 컬렉터
--------------------

	1.	c/c++ 동적 메모리 관리 방식

		-	C런타임은 객체를 담기 위한 메모리를 여러개의 블록으로 나눈뒤
			
			링크드 리스트로 묶어 관리함.

		-	C 런타임의 메모리 할당 순서.

			1)	객체(변수)의 메모리 할당 시도.

			2)	메모리 링크드 리스트 순차적 탐색.

			3)	해당 객체를 담을 만한 여유가 있는 메모리 블록 찾기.

			4)	적절한 크기의 메모리 블록을 찾으면 이 메모리 블록을 쪼개서 객체를 할당.

			5)	메모리 블록의 링크드 리스트 재조정.

			-	공간 탐색 -> 분할 -> 재조정.

		-	메모리 관리시 개발자의 유의사항.

			-	동적으로 사용한 메모리는 반드시 해제.
				
				-	수동 메모리 관리.

					-	메모리 관리에 대한 책임을 개발자가 맡는 것.

			-	해제한 메모리를 가리키는 포인터에 접근하지 말것.

	
	2.	c#의 메모리 관리 방식

		-	메모리 관리에 대한 책임은 CLR이 담당.

			-	CLR의 가비지 컬렉터.

				-	수동 메모리 관리에 비해 개발자의 부담이 상당히 적어짐.

				-	더이상 사용하지 않는 메모리를 쓰레기( Garbage )로 분류.

				-	가비지 처리시 CPU나 메모리 같은 자원을 소모.

					-	프로그램 런타임시 퍼포먼스 저하 원인.

				->	퍼포먼스 최적화시 목표
				
					-	가비지 컬렉터가 최소한으로 메모리 자원을 사용하게 만드는 것.



--------------------
2.	CLR의 메모리 관리.
--------------------

	1.	메모리 할당.

		-	순서.

			1)	프로그램을 위한 일정 크기의 메모리 확보. ( Managed Heap )

			------------------------------------------------------------------------
			|	|	|	|	|	|	|	|	|	|	|	|	|	|	|	|	|	|	|
			------------------------------------------------------------------------
																	< Managed Heap >	


			2)	Managed Heap의 첫번째 주소에 "다음 객체를 할당할 메모리의 포인터"를 위치 시킴.

			------------------------------------------------------------------------
			|	|	|	|	|	|	|	|	|	|	|	|	|	|	|	|	|	|	|
			------------------------------------------------------------------------
			^
			|
			 ---- "다음 객체를 할당할 메모리의 포인터"


			3)	메모리 할당시 "다음 객체를 할당할 메모리의 포인터"가 가리키고 있는 주소에

				메모리를 할당하고 해당 메모리 바로 뒤로 포인터를 이동 시킴.

			------------------------------------------------------------------------
			|		메모리 할당 공간	|	|	|	|	|	|	|	|	|	|	|	|
			------------------------------------------------------------------------
											^
											|
											 --- "다음 객체를 할당할 메모리의 포인터"

			4)	3)번 작업 반복.


		
			->	메모리 할당시 할당 공간을 탐색하거나, 할당을 위한 공간 재조정 과정 필요없음.

				-	단순 할당 방식.

				


	2.	메모리 해제.

		-	메모리 생성 영역

			-	값 형식		:	스택

				참조 형식	:	힙

		-	예)

				if( true )
				{
					object a = new object();
				}
				

				-	참조 형식 생성시

					실제 생성되는 메모리는 힙에 할당되며

					변수 a는 스택에 할당되며 실제 할당된 메모리의 주소값을 저장함.
					
					-	할당된 메모리의 주소값을 저장 = 할당된 메모리의 위치를 참조.

					-	루트
							
						-	할당된 메모리의 위치를 참조하는 객체.

						-	스택이나 정적 필드.

					-------------------------
					| a	|	|	|	|	|	|
					-------------------------
					  |					< 스택 >
					  |
					  |		-------------------------
						->	| 	new object	|	|	|
							-------------------------
												< 힙 >

				-	코드블록을 벗어날때 a는 스택에서 사라지지만

					힙에 생성된 메모리는 사라지지 않음.


					-------------------------
					| 	|	|	|	|	|	|
					-------------------------
					  					< 스택 >
					  
			  		-------------------------
					| 	new object	|	|	|
					-------------------------
										< 힙 >

				-	힙에 생성된 메모리는 코드 어디에서도 접근할 수 없으므로

					더이상 사용할 수 없음.( 가비지 )


				-	JIT 컴파일러가 루트들을 목록으로 만들고
					
					CLR은 루트 목록을 관리하며 상태를 갱신.

				-	가비지 컬렉터는 CLR이 관리하는 루트 목록을 참조하여

					가비지 컬랙팅.


		-	가비지 컬렉터가 가비지를 정리하는 과정.

			1)	작업 시작 전, 가비지 컬렉터는 모든 객체가 가비지라고 가정.

				->	루트 목록내의 어떤 루트도 메모리를 가리키지 않는다고 가정.

			2)	루트 목록을 순회하며 각 루트와 힙 객체와의 관계여부 조사.

				-	어떤 루트(Root A)가 참조하고 있는 힙의 객체(Heap A)가 또 다른 힙 객체(Heap B)를 참조하고 있다면

					Heap B도 Root A와 관계가 있는 것으로 판단.

					-	아무런 루트와도 관계가 없는 힙의 객체들은 가비지로 간주.

			-------------------------------------
			|			루트 목록				|
			|	( 스택 객체, 정적 필드 등.)		|
			-------------------------------------
			|	|				
			|	--------------------|
			-----------------------------------------------------------------
			|		A		|	B	| C	|		D	 	| E	| F	|	|	|	|
			-----------------------------------------------------------------
									  |					  |		^
									  --------------------		|
																 --- "다음 객체를 할당할 메모리의 포인터"

			3)	가비지가 차지하고 있던 메모리 공간은 해제되어 빈 공간이 됨.


			-------------------------------------
			|			루트 목록				|
			|	( 스택 객체, 정적 필드 등.)		|
			-------------------------------------
			|	|				
			|	--------------------|
			-----------------------------------------------------------------
			|		A		|		| C	|			 	| E	| 	|	|	|	|
			-----------------------------------------------------------------
									  |					  |		^
									  --------------------		|
																 --- "다음 객체를 할당할 메모리의 포인터"

			4)	루트 목록 조사후, 힙을 순회하며 가비지가 차지하고 있던 빈 공간에 인접 객체들을 이동 시켜 채워넣음.

			
			-------------------------------------
			|			루트 목록				|
			|	( 스택 객체, 정적 필드 등.)		|
			-------------------------------------
			|	|				
			|	------------|
			-----------------------------------------------------------------
			|		A		| C	| E	| 	|	|	|	|
			-----------------------------------------------------------------
							  |---|	^
									|
									 --- "다음 객체를 할당할 메모리의 포인터"
					


-------------------------
3.	세대별 가비지 컬렉션
-------------------------
	
	1.	CLR의 세대별 메모리 관리

		-	메모리를 0, 1, 2의 3개의 세대( Generation )으로 구분.

		-	0 세대 
			
			-	갓 생성된 객체들.
						
			1 세대

			-	가비지 컬렉션 1회를 거친 후 살아남은 객체들.

			2 세대

			-	최소 2회이상의 가비지 컬렉션을 거치고도 살아남은 객체들.


	2.	순서

		1)	프로그램 실행시 CLR은 비어있는 Managed Heap 확보.

			------------------------------------------------------------------------
			|	|	|	|	|	|	|	|	|	|	|	|	|	|	|	|	|	|	|
			------------------------------------------------------------------------
																	< Managed Heap >

		2)	프로그램 진행 중 할당된 객체들로 힙이 채워짐.

			<---------- 0 세대 ------------->
			------------------------------------------------------------------------
			|	A	|	B	| C	|	D	| E |	|	|	|	|	|	|	|	|	|	|
			------------------------------------------------------------------------
																	< Managed Heap >

		3)	0 세대 가비지 컬렉션 한계 도달시, 0 세대에 대해 가비지 컬렉션 진행.

			살아남은 객체들은 1세대로 옮김.

			<--- 1 세대 --->
			------------------------------------------------------------------------
			|	A	| C	| E |	|	|	|	|	|	|	|	|	|	|	|	|	|	|
			------------------------------------------------------------------------
																	< Managed Heap >

		4)	프로그램 진행 중 새로 생성된 객체들은 0 세대에 할당.

			<--- 1 세대 ---><----------------- 0 세대 --------------------->
			------------------------------------------------------------------------
			|	A	| C	| E |	F	| G |		H		|	I	|	J	| K	|	|	|
			------------------------------------------------------------------------
																	< Managed Heap >
		
		5)	3번 현상 반복.

			<--------------------- 1 세대 ---------------------->
			------------------------------------------------------------------------
			|	A	| C	| E |	F	| 		H		|	J	| K	|	|	|	|	|	|
			------------------------------------------------------------------------
																	< Managed Heap >

		6)	0 세대에 새로 생성된 객체들 할당.
		
			1세대 한계치 도달, 1 세대에 대해 가비지 컬렉션 진행.

			이 때 가비지 컬렉션은 하위 세대에 대해서도 가비지 컬렉션을 수행.

			->	0, 1 세대에 대한 가비지 컬렉션 수행.

			->	0 세대 생존 객체들은 1 세대, 

				1 세대 생존 객체들은 2 세대로 이동.

			<--------- 2 세대 ---------><--- 1 세대 --->
			------------------------------------------------------------------------
			|	A	| C	| F	|	J	| K	| L	|	M	| O	|	|	|	|	|	|	|	|
			------------------------------------------------------------------------
																	< Managed Heap >

		7)	6번 현상 반복 중,

			2세대 포화, 2 세대에 대한 가비지 컬렉션 수행.

			->	2, 1, 0 세대 대한 가비지 컬렉션 수행.

				->	2 세대 가비지 컬렉션 = 전체 가비지 컬렉션( Full Garbage Collection )
				
			<------------- 2 세대 --------------><----- 1 세대 ----->
			------------------------------------------------------------------------
			| C	| F	|	J	| K	| L	|	M	| O	|	P	|	Q	| R	|	|	|
			------------------------------------------------------------------------
																	< Managed Heap >


	3.	정리.

		-	가비지 컬렉션 빈도

			2 세대 < 1 세대 < 0 세대

		-	퍼포먼스 저하현상.
		
			-	CLR은 애플리케이션의 실행을 잠시 멈추고

				전체 가비지 컬렉션 수행( Full GC )하여 여유 메모리 확보시도.

			-	애플리케이션이 차지한 메모리가 클수록 Full GC 시간이 길어지므로

				정지하는 시간도 그만큼 늘어남.

			
-------------------------
4.	가비지 컬렉션 대처 방안.
-------------------------

	1)	객체의 과다 할당 지양.

		-	CLR의 객체 할당속도가 빠르긴 하지만

			너무 많은 수의 객체는 Managed Heap의 각 세대에 대해 메모리 포화상태를 촉발함.

			-	꼭 필요한 객체인지, 필요 이상으로 많은 객체를 생성하는 건 아닌지 고려할 것.

	2)	큰 객체 할당 지양.

		-	CLR은 대형 객체를 위해 힙을 구분해서 관리함.

			-	대형 객체 힙( LOH : Large Object Heap )	/ 소형 객체 힙( SOH : Small Object Heap )	

				-	LOH
					
					-	85KB 이상의 대형 객체 할당용.

			-	대형 객체를 구분 하지 않으면 0 세대가 빠르게 포화되므로 가비지 컬렉션이 

				자주 촉발됨.

			-	차이
			
					동작		|	SOH								|		LOH
				---------------------------------------------------------------------------------------
				객체할당		|	"다음 객체를 할당할 포인터"가	|	객체의 크기를 계산한 후
								|	위치한 메모리로 바로 할당.		|	여유공간이 있는지 탐색후 할당.
				---------------------------------------------------------------------------------------
				GC 수행후 처리	|	해제된 메모리 공간에 			|	해제된 공간 유지.
								|	인접 객체를 이동시켜 정리		|	->	추후 다른 객체들에게 할당.
								|	->	메모리 낭비 없음.			|		메모리 정리가 없어 군데군데 낭비 발생.
								|									|	->	동작 방식이 C 런타임과 비슷.
				---------------------------------------------------------------------------------------
				할당 위치		|	0 세대							|	2 세대
								|									|	->	객체 수거시 2 세대에 대한 GC 촉발
								|									|	->	Full GC 진행.
				---------------------------------------------------------------------------------------


	3)	복잡한 참조 관계 지양.

		-	가비지 컬렉터는 가비지 컬렉션 후 살아남은 객체의 세대를 옮기기 위해 메모리 복사 수행.

			참조 관계가 복잡한 객체는 각 필드 객체간의 참조관계를 일일이 조사후
			
			참조하고 있는 메모리 주소를 전부 수정.

		-	class A
			{
				public C c;
			}

			class D
			{
				public A a;
				public B b;
				public C c;
			}
			
			D 클래스 자체는 2세대에 존재하고 A 형식의 필드 a를 새로 생성한 객체로 갱신했다면,

			D의 인스턴스는 2세대, a필드가 참조하고 있는 메모리는 0 세대에 위치함.

			루트를 갖고 있지 않는 이전 a의 참조 메모리는 0 세대 가비지 컬렉션에 의해 수거될 가능성이 높음.

			이때, CLR은 쓰기장벽( Write Barrier )을 통하여 a 필드가 루트를 갖고 있는 것으로 간주하게 하여

			0세대 가비지 컬렉션을 모면하게 함.

			->	쓰기 장벽생성시 발생하는 오버헤드가 적지 않음.


	4)	루트 과다 생성 지양.

		-	가비지 컬렉터는 루트 목록을 조회하면서 가비지를 탐색함.

			-	루트 목록이 작을수록 조회 횟수가 감소하므로 가비지 컬렉션 시간 감소.