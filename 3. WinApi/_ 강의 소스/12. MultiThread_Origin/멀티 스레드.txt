/// 멀티 스레드 ////////////////////////////////////////////////////////////////
------------
1.	스레드
------------
	1.	정의
			-	프로세스 내에 존재하는 일련의 실행 코드.
			-	주로 함수단위의 코드.
			-	WinMain, 메시지 루프, 윈도우 프로시져, 일반 함수등..
			-	프로세스 생성시 하나의 주 스레드가 생성됨.(WinMain, main 함수)
			-	대부분의 경우 주스레드가 모든 작업을 처리하고 주 스레드가 종료되면 프로세스도 같이 종료됨.
	
	2.	멀티 태스킹	-	하나의 운영체제에 여러 개의 프로세스가 동시에 실행되는 환경.
		멀티 스레드	-	하나의 프로세스에서 여러 개의 스레드가 동시에 실행되는 환경.

	3.	고전적인 다중 작업.
			-	"1. MultiTask" 참고.
			
			-	문제점
					-	WM_TIMER의 제한적 발생횟수	:	초당 약 20회가 최대 발생횟수.
					-	타이머에서 작업을 하는 동안은 다른 메시지를 곧바로 처리할 수 없음.
					-	파일 저장등 분할하기 힘들거나 속도가 너무 느려지는 작업에는 부적합.
	
	4.	스레드 생성.
			-	CreateThread, 스레드 처리 함수, CloseHandle
			-	"2. Thread" 참고.


------------
2.	스레드 관리
------------
	1.	실제 스레드 프로세스
		-	실제 스레드는 일정한 백그라운드 작업을 맡아 처리하고 작업이 끝나면 종료된다.
			예) 인쇄, 다운로드 등.
	
		-	작업이 종료되면 스레드 처리 함수가 종료되며 스레드도 파괴된다.

		-	일반적으로 메인 스레드와 작업 스레드는 서로 독립적이다.
			-	메인 스레드는 작업 스레드를 만들기만 하고 종료 상태에는 상관하지 않는다.
			-	하지만 작업 스레드가 종료되었는지 여부는 주기적으로 체크해야한다.		
				
				-	BOOL GetExitCodeThread( HANDLE hThread, LPDWORD lpExitCode )
					hThread		:	관심 스레드 핸들.
					lpExitCode	:	종료 코드.
									실행중	:	STILL_ACTIVE
									종료	:	스레드 처리함수의 리턴 값.
												ExitThread 함수의 인수.

			-	같은 프로세스내의 스레드끼리는 주소공간, 전역변수, 코드를 공유.

		-	작업 스레드가 무한루프를 돌고 있을때 종료시점은?
			-	모든 스레드는 프로세스 종료시 강제 종료되므로 무한 루프로 만들어도 상관없음.
			-	메인 스레드가 종료되면 프로세스가 종료되므로 작업 스레드도 종료.
				-	프로세스 종료될때까지 계속 실행됨.
	
	
	2.	작업 중간에 스레드를 종료해야 하는 경우의 처리.
		-	일반적으로 작업 스레드는 정해진 작업을 순서대로 처리한 후 종료됨.
		-	작업 중간에 스레드를 종료해야 하는 경우
			예)	다운로드 중 취소.

			VOID	ExitThread( DWORD dwExitCode )
			-	스레드가 스스로를 종료 시킬때 사용.
			-	dwExitCode	:	종료 코드.
								메인 스레드에서 GetExitCodeThread를 이용해서 조사.
			-	해당 스레드가 이 함수를 호출하면 
				자신의 스택을 해제하고 연결된 DLL을 모두 분리한 후 스스로 파괴된다.
			-	c++ 클래스의 파괴자가 호출되지 않고 c런타임이 만든 고유의 데이터 블록이
				해제되지 않는 문제점 있음.


			BOOL	TerminateThread( HANDLE hThread, DWORD dwExitCode )
			-	주로 메인 스레드가 작업 스레드를 강제로 종료하고자 할 때 사용.
			-	스레드와 연결된 DLL 에게 어떠한 통보도 하지 않는다.
				-	연결된 DLL들이 적당한 종료처리를 못할 수도 있음.
				-	할당된 자원들이 제대로 해제되지 않을 수도 있음.
			-	위급한 상황에만 사용 할 것.	
				-	스레드가 어떤 작업을 하고 있는지 알고 있을때.
				-	스레드 종료 후 어떤 일이 벌어질지 예상 가능할때.
		
		-	스레드를 중간에 종료할때에는 전역변수나 그외 다른 방법을 통하여
			해당 스레드가 종료 사실을 알수 있게 하여 스스로 종료하도록 하는 것을 권장.
		
		-	스레드가 작업을 무사히 마치고 return 문으로 스레드 처리 함수를 종료하는 것이 
			가장 바람직한 방법.

	3.	스레드의 일시정지 / 재개

		-	스레드의 동작 일시 정지/재개
			DWORD	SuspendThread( HANDLE hThread )
			:	스레드의 동작을 일시 중지.	

			DWORD	ResumeThread( HANDLE hThread )
			:	중지된 스레드를 재개.
			
			*	스레드는 내부적으로 중지 카운트를 가지고 있는데
				이 카운트는 SuspendThread를 호출하면 증가하고
				ResumeThread를 호출하면 감소하여 0이 되면 재개한다.
				-> 만약 SuspendThread를 3번 호출했다면 ResumeThread도 3번 호출해야
				재개된다.


				

------------
3.	스케쥴링
------------
	1.	스케쥴링	:	스레드를 어떤 순서로 얼마만큼의 간격으로 실행할 것인가 결정.
		-	운영체제의 스케쥴링에 의해서 스레드의 실행 순서가 결정된다.			
		-	운영체제는 CPU의 실행시간을 아주 잘개 쪼개어 스레드를 조금씩 순서대로 실행하여
			동시에 실행되는 것처럼 보임.
		-	운영체제 버전과 목적,설정 상태에따라 시간이 설정됨.
			(대략 0.02초 정도이며 분할된 시간조각을 퀀텀이라고 함.) 
		-	멀티스레드란 실제로 여러개의 스레드가 동시에 실행되는 것이 아니다.
			굉장히 빠른 속도로 스레드를 번갈아가며 실행하는 것.( 라운드 로빈 방식)

			
					-	스레드 1
					-	스레드 2
			CPU		-	스레드 3
					-	스레드 4
					-	스레드 5

				스레드 1을 1퀀텀 동안 실행	->
				1퀀텀 후 1 실행을 잠시 중지	->
				2를 실행(스위칭)			->
				1퀀텀 후 2 실행 중지		->
				3을 실행(스위칭)			->
				......

		-	스레드 컨택스트		:	스레드가 스위칭 될때 이전 스레드의 실행 상태에대한 정보를
									어딘가에 저장해야 다음 작업때 이어서 할수 있음.
									이때, 스레드의 실행 상태에대한 정보를 일컬음.

		-	특정 스레드의 컨텍스트 정보를 구하거나 변경할때 사용하는 함수.
			
			BOOL	GetThreadContext( HANDLE hThread, LPCONTEXT lpContext)
			BOOL	SetThreadContext( HANDLE hThread, const CONTEXT* lpContext )
		
			*	디버깅을 위해 사용권장.
				스레드를 임의 조작하는 것은 바람직 하지 않다.
	
	2.	우선순위
		-	스레드 중에도 사용자로부터 입력을 처리하는 바쁜 스레드(예: 작업 관리자)가 있고
			백그라운드에서 아무런 작업 없이 대기하고 있는 스레드도 있다.(예: 스크린 세이버)
		-	스레드 간의 우선 순위를 설저하여 급한 스레드에게 더 많은 시간을 할애하는 것이 합리적.
		-	우선순위 클래스와 우선순위 레벨값의 조합으로 결정됨.
		
		-	기본 우선 순위
			:	Get(Set)PriorityClass(우선순위 클래스),
				Get(Set)ThreadPriority(우선순위 레벨)으로 기본 우선순위 결정.
			:	0 ~ 31까지의 범위를 가짐.
			:	0		-	시스템만이 가질수 있는 가장 낮은 순위.
			:	7 ~ 11	-	대부분의 스레드가 동작하는 범위.


		-	동적 우선 순위	
			:	기본 우선 순위가 결정되더라도 실제 적용되는 우선 순위는
				실행중에 시스템에 의해 계속 변경되는 현상.
			:	스케쥴러가 스레드를 실행할때 실제로 적용하는 값.

		-	우선 순위 부스트
			:	시스템은 스레드의 반응성을 높이면서도 다른 스레드의 실행시간을 지나치게 뺏지 않도록
				가장 합리적이고 효율적인 방법으로 스레드의 우선순위를 높이거나 낮춤.		
			:	SetThreadPriorityBoost등의 함수 사용.
			
			*	대부분의 우선순위 결정은 운영체제에 맡기는게 낫다.
			
				
------------
4.	주의 사항.
------------
	1.	전역변수, 스태틱 변수의 공유.
		-	지역변수를 활용하거나 TLS(Thread Local Sotrage)방법으로 해결 가능.
		-	_declspec(threaad)	:	TLS로 지정하고 싶은 변수 앞에 선언 해주면 해당 변수는 스레드의 지역 변수가 됨.

	2.	스레드의 호출순서를 예상할 수 없음.
		-	스레드가 작업 중일 때 압축을 푼다거나 동영상을 재생한다면
			해당 스레드가 시간을 받지 못해 정해진 시간안에 작업을 완료하지 못할 수도 있음.

	3.	CreateThread와 Exit의 불안전성.
		-	C언어가 제공하는 일부 기능중 C 라이브러리전체가 공유하는 전역변수와 몇몇 함수들이
			사용하는 정적 변수들이 문제를 문제를 일으킬 수 있음.
			예)	ermo	:	어떤 함수를 호출후 함수 실행 중 에러가 발생했는지 여부를 알수 있는 전역변수.
				strok	:	문자열을 토큰으로 분할 하는 함수.
														
			#include <string.h>  
			#include <stdio.h>  
 
			char string[] = "A string\tof ,,tokens\nand some  more tokens";
			char seps[] = " ,\t\n";
			char *token;
 
			int main(void)
			{ 
					printf("Tokens:\n");
 
					// Establish string and get the first token:  
					token = strtok(string, seps);                                                             
					while (token != NULL)
					{
						   // While there are tokens in "string"  
						   printf(" %s\n", token);
 
						   // Get next token:   
						   token = strtok(NULL, seps); 
					}
			}
			

			-	C 언어는 멀티스레드 개념이전의 언어.
			-	속성 - C/C++ - 코드 생성 - 런타임 라이브러리 - 다중 스레드 (디버그)
			
		-	API함수가 C언어에 대해 이런 처리를 하지 않은 이유?
			:	윈도우즈 프로그램을 반드시 C언어로 만들어야 한다는 제약이 없음.
			:	운영체제가 프로그래밍 언어의 문제점까지 책임 질 필요는 없음.
				-	운영체제는 스레드 생성에 필수적인 처리를 제공하는 함수만 제공하고
					어떻게 사용할지는 프로그래밍 언어나 개발툴이 상황에 맞게 결정.
				
		-	_beginthreadex / _endthreadex 사용 권장.

		-	_beginthreadex()
			{
				TLS에 메모리 할당.
				CreateThread로 스레드 생성.
				TLS의 메모리 해제.
			}

			_endthreadex()
			{
				TLS 해제.
				ExitThread로 스레드 해제.
			}
		

		*	예제가 단순하고
			문제가 되는 C 함수를 사용하지 않기 때문에
			그냥 CreateThrea / ExitThread를 사용했음.