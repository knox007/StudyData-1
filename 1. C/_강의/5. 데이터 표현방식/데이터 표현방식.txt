/// 데이터 표현방식 /////////////////////////////////////////////////////////

-----------------------------
1.	2진수, 8진수, 10진수, 16진수
-----------------------------
	1.	정의
			2진수	:	0과1, 두개의 숫자로 수를 표현하는 방식.
			8진수	:	0~7, 8개의 숫자로 수를 표현하는 방식.
			10진수	:	0~9, 10개의 숫자로 수를 표현하는 방식.
			16진수	:	0~9,A~F, 16개의 숫자로 수를 표현하는 방식.


	2.	변환

		-------------------------------------		
		10진수		|	2진수
		-------------------------------------
		0		|	0
		1		|	1
		2		|	10
		3		|	11
		7		|	111
		-------------------------------------
		10진수		|	8진수
		-------------------------------------
		0		|	0
		1		|	1
		2		|	2
		3		|	3
		7		|	7
		10		|	12
		11		|	13
		15		|	17
		20		|	24
		-------------------------------------
		10진수		|	16진수
		-------------------------------------
		0		|	0
		1		|	1
		2		|	2
		3		|	3
		9		|	9
		10		|	A
		11		|	B
		15		|	F
		20		|	14


	3.	표현
			int n1 = 10;	//	특별한 선언이 없으면 10진수.

			int n2 = 0xA;	//	0x로 시작하면 16진수.

			int n3 = 012;	//	0으로 시작하면 8진수.
			
			* 2진수는 특별한 서식 표현이 없음.


	4.	소스 참고( "Number System" )




-----------------------------
2.	비트와 바이트
-----------------------------
	
	1.	정의
			
		-	비트	

			-	컴퓨터가 표현하는 데이터의 최소단위.

			-	2진수 값 하나를 저장할 수 있는 메모리 크기.

				-	0, 1

				
		-	바이트	

			-	1바이트 = 8비트.

	
		


-----------------------------
3.	정수의 표현방식.
-----------------------------
	

	1.	표현방식
		
		:	정수를 1바이트로 표현한다 가정했을 때(int의 경우 4바이트),

			정수 +1을 1바이트 메모리 공간에 저장한다면 

		-------------------------------------------------------------------------------------------------------------------------------------------------
		|	0	|	0	|	0	|	0	|	0	|	0	|	0	|	1	|
		-------------------------------------------------------------------------------------------------------------------------------------------------
		|----- 부호 ----|--------------------------------------------- 정수의 크기 -----------------------------------------------------|	


		-	부호비트 	

			- 	가장 왼쪽에 존재하는 비트.

				-	MSB( Most Significant Bit, 가장 중효한 비트 )라고함.

			-	unsigned( 부호 없는 데이타형 ) 인 경우 숫자를 표현하는데 사용.

				signed 인 경우 부호를 표시하며 양수라면 0, 음수라면 1.



			






	2.	음의 정수 표현.

		-	부호비트만 1로 바꿔주면 되는 것 아닌가??

			->	부호 절대값 방식

			
			예)	5 + (-5) = 0

				0 0 0 0 0 1 0 1	-> (+5)

			     +	1 0 0 0 0 1 0 1 -> (-5)
			    ---------------------
				1 0 0 0 1 0 1 0 -> (0이 아님)


		-	부호 절대값 방식의 단점

			-	2개의 '0'이 존재하게 됨

				-	표현할 수 있는 숫자가 하나 줄어듬.









	3.	옳바른 음의 정수 표현.
		
		-	2의 보수법
		
			1)	각 비트를 1의 보수로 바꾼다( 1->0, 0->1 )

			->	0 0 0 0 0 1 0 1	-> 1 1 1 1 1 0 1 0

			2)	1을 더한다
		
			->	1 1 1 1 1 0 1 0 + 0 0 0 0 0 0 0 1 -> 1 1 1 1 1 0 1 1 

				예)
					0 0 0 0 0 1 0 1	-> (+5)

				     +	1 1 1 1 1 0 1 1 -> (-5)
				    ---------------------
				      1 0 0 0 0 0 0 0 0 -> (올림수는 버려져서 0이된다.)


	

		
-----------------------------
4.	실수의 표현방식.
-----------------------------

	1.	표현방식
		
		:	실수를 2바이트로 표현한다 가정했을 때(float의 경우 4바이트),

			2바이트 중 반은 정수, 나머지 반은 소수점으로 표현한다면

	
			1 0 0 0 0 0 0 1   0 0 0 0 0 1 0 1
			
			->	부호비트 	: 	1
				정수 부분	:	1
				실수 부분	:	5

			-> 	-1.5
				이런식이라면 충분한 범위의 실수를 표현하는데 한계가 생긴다.


	2.	실제 표현방식
		
		:	부호비트, 나머지 7비트 : e, 나머지 8비트(1바이트) : m

			-> +-(1.m) * 2^e-127

	3.	실수 표현 방식의 오차.

		:	넓은 범위의 실수를 표현할 수 있지만 오차가 존재한다.


			예) 0.0 을 +-(1.m) * 2^e-127으로 표현 가능한가?

			:	2의 n승으로는 절대로 0이 될 수 없다.
				
			->	컴퓨터는 우리가 표현하고자 하는 실수의 값을 정확하게 표현하는 것이 아니라

				문제가 없을 만큼의 근사치를 통해서 실수를 표현한다.

				이때 발생하는 오차를 '부동 소수점 오차' 라고 한다.
		



	4.	소스 참고( "float error" )	




-----------------------------
5.	비트 연산자.
-----------------------------

	1.	종류
		
			연산자	|		기능		|	
		     ----------------------------------------------------
			&	|		AND		|	
			|	|		OR 		|
			^	|		XOR 		|
			~	|	모든 비트의 반전		|
			<<	|	왼쪽 비트 이동 연산자	|
			>>	|	오른쪽 비트 이동 연산자	|




	2.	소스 참고( "Bit Operator" )


