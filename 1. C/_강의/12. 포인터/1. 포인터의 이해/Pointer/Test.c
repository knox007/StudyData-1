//======================================================
#pragma warning (disable : 4996)
#include <stdio.h>
//======================================================
/*
1.	포인터 변수 선언과 할당.

	-	가리키고자 하는 변수의 자료형에 따라 선언 방식이 달라짐.
	
	-	포인터 변수는 모두 정수의 형태를 지니며
	
		크기는 컴파일러의 작업 환경에 따라 모두 동일하다.( x86 : 4바이트, x64 : 8바이트 )

	-	type* var /  type * var / type *var
		
		*연산자의 위치는 상관없음.
*/

/*
int main(void)
{
	char *pChar, tmpChar = 'a';
	int *pInt, tmpInt = 100;
	
	pChar = &tmpChar;
	pInt = &tmpInt;

	int charPtrLen = sizeof(pChar);
	int intPtrLen = sizeof(pInt);
		
	printf("pChar = %p,  pInt = %p\n", pChar, pInt);
	printf("tmpChar 주소 = %p,  tmpInt 주소 = %p\n", &tmpChar, &tmpInt);
	printf("charPtrLen = %d,  intPtrLen = %d\n", charPtrLen, intPtrLen);

	return 0;
}
//*/
//======================================================
/*
	실습)	float, double도 직접 확인해본다.

*/



//======================================================
/*
2.	& 연산자와 * 연산자

	-	& 연산자
		-	피연산자의 주소값 반환.

		-	피연산자는 변수여야 함, 상수는 안됨.

		-	일반적으로 "포인터가 변수 A의 주소값을 가지고 있다"

			-	"포인터가 변수 A를 가리킨다"라고 표현.

		-	변수의 자료형에 맞지않는 포인터 변수의 선언은 문제가 됨.
		
			예)	int num = 100;
				double *pNum = &num;	(X)

				int num = 100;
				int *pNum = &num;		(O)
	
	
	-	* 연산자
		-	포인터가 가리키는 메모리 공간에 접근할 때 사용.

			예)	int num = 10;
				int *pNum = &num;

				*pNum = 20;				->	pNum이 가리키는 메모리 공간에 20을 저장.
				->	num = 20;
				printf("%d", *pNUm);	->	pNum이 가리키는 메모리 공간에 저장된 값을 출력.

				->	*pNum == num				
*/



/*
int main(void)
{
	int num1 = 100, num2 = 100;
	int *pNum;

	pNum = &num1;
	(*pNum) += 30;

	pNum = &num2;
	(*pNum) -= 30;

	printf("num1 = %d,  num2 = %d\n", num1, num2);

	return 0;
}
//*/
//======================================================



//======================================================
/*
3.	다양한 포인터 타입이 존재하는 이유.

	-	포인터 변수는 모두 정수의 형태를 지니며
	
		크기는 컴파일러의 작업 환경에 따라 모두 동일하다.( x86 : 4바이트, x64 : 8바이트 )
		
		( 1.	포인터 변수 선언과 할당. 참조 )

		-	변수가 관리하는 값과 크기가 동일하다면 굳이 타입에 따라 다르게 포인터를 선언할 필요가 있을까?

			-	포인터의 타입은 메모리 공간을 참조하는 기준이 된다.

				예)	return *pNum;

					-	pNum에 저장된 주소로부터 몇바이트를 읽어들여야 하는가?

					-	읽어들인 데이터는 정수또는 실수로 해석해야 하는가?

*/


/*
int main(void)
{
	double num = 3.14;		//	8바이트 실수형 데이터.

	int* pNum = &num;		//	4바이트 정수형데이터의 주소 관리. 타입 불일치!!

	printf("%d\n", *pNum);	//	예측 불가능한 무의미한 출력!!

	return 0;
}
//*/
//======================================================




//======================================================
/*
4.	잘못된 포인터 사용과 널(null)포인터

	1)	포인터 선언후 초기화 하지 않으면?

		-	포인터도 변수이므로 지역 변수로 선언된 경우 쓰레기 값으로 초기화 된다.( 0xcccccccc )

			전역변수 인 경우 0으로 자동 초기화.

		-	예)	int *ptr;
				*ptr = 200;

	2)	int *ptr = 200;		->	200번지??
		*ptr = 100;

		-	상수를 입력하면 해당 상수를 주소로 인식.
			
			-	만약 그 메모리 공간이 시스템의 중요한 위치라면 시스템 전체에 심각한 문제를 일으킬 수 있음.

		-	일반적으로 포인터 변수를 선언하고 이후에 유효한 주소값을 넣으려고 한다면 null값으로 초기화 한다.
			
			예)	int* ptr1 = 0;
				int* ptr2 = null;	사실상 0과 같음.								
				->	아무데도 가리키지 않는다는 의미.(0번지가 아님)

*/
//======================================================