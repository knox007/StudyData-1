//======================================================
#include <stdio.h>
//======================================================
/*
1.	& 연산자.(AND)

	:	두개의 비트가 모두 1일 때 1을 반환.

	피연산자 A	| 피연산자 B	|	결과
	-------------------------------------
		0		|		0		|	0
		0		|		1		|	0
		1		|		0		|	0
		1		|		1		|	1
*/
//*
int main(void)
{
	int n1 = 15;		//	00000000	00000000	00000000	00001111
	int n2 = 20;		//										00010100
	int n3 = n1 & n2;	//										????????			

	printf("n1 & n2 = %d\n", n3);

	return 0;
}
//*/
//======================================================


//======================================================
/*
2.	| 연산자.(OR)

:	두개의 비트 중 하나라도 1이면 1을 반환

피연산자 A	| 피연산자 B	|	결과
-------------------------------------
0		|		0		|	0
0		|		1		|	1
1		|		0		|	1
1		|		1		|	1
*/

/*
int main(void)
{
int n1 = 15;		//	00000000	00000000	00000000	00001111
int n2 = 20;		//										00010100
int n3 = n1 | n2;	//										????????

printf("n1 | n2 = %d\n", n3);

return 0;
}
//*/
//======================================================



//======================================================
/*
3.	^ 연산자.(XOR, 베타적 OR)

:	두개의 비트가 서로 다른 경우 1을 반환

피연산자 A	| 피연산자 B	|	결과
-------------------------------------
	0		|		0		|	0
	0		|		1		|	1
	1		|		0		|	1
	1		|		1		|	0
*/

/*
int main(void)
{
	int n1 = 15;		//	00000000	00000000	00000000	00001111
	int n2 = 20;		//										00010100
	int n3 = n1 ^ n2;	//										????????

	printf("n1 ^ n2 = %d\n", n3);

	return 0;
}
//*/
//======================================================


//======================================================
/*
4.	~ 연산자.(NOT)

:	비트를 반전시킴.
	0 -> 1
	1 -> 0
*/

/*
int main(void)
{
	int n1 = 15;		//	00000000	00000000	00000000	00001111
	int n2 = ~n1;		//	????????	????????	????????	????????

	printf("~n1 = %d\n", n2);

	return 0;
}
//*/
//======================================================


//======================================================
/*
5.	<<, >> 연산자 ( Shift 연산자 )

:	비트를 이동시킴.
	빈칸은 0으로 채우고 밀려나는 비트들은 버려진다.

:	>> 연산자는 음수를 처리할 경우
	cpu에 따라 결과가 달라진다

	-16 >> 2		:		11111111	11111111	11111111	11110000
		1.	음의 값을 유지하기 위해 1을 채우는 경우.
		->	11111111	11111111	11111111	11111100	

		2.	음의 값 유지에 상관없이 0을 채우는 경우.
		->	00111111	11111111	11111111	11111100
		

*/
/*
int main(void)
{
	int n1 = 16;		//	00000000	00000000	00000000	00010000
	int res1 = n1 << 1;
	int res2 = n1 << 2;
	int res3 = n1 << 3;

	printf("----------------------------\n");
	printf("n1 = %d\n", n1);
	printf("----------------------------\n");
	printf("n1 << 1 -> %d\n", res1);
	printf("n1 << 2 -> %d\n", res2);
	printf("n1 << 3 -> %d\n", res3);

	int n2 = -16;		//	11111111	11111111	11111111	11110000
	int res4 = n2 >> 1;
	int res5 = n2 >> 2;
	int res6 = n2 >> 3;
	printf("----------------------------\n");
	printf("n2 = %d\n", n2);
	printf("----------------------------\n");
	printf("n2 >> 1 -> %d\n", res4);
	printf("n2 >> 2 -> %d\n", res5);
	printf("n2 >> 3 -> %d\n", res6);


	return 0;
}
//*/
//======================================================