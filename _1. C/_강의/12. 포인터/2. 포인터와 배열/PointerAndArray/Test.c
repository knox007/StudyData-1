//======================================================
#pragma warning (disable : 4996)
#include <stdio.h>
//======================================================
/*
1.	배열의 이름.
	-	배열의 이름은 '상수형태의 포인터'이다.
		
		즉, 배열의 주소값이다.
*/

/*
int main(void)
{
	int arr[3] = { 0,1,2 };

	printf("배열의 이름 arr : %p\n", arr);
	printf("배열 arr의 첫번째 요소 : %p\n", &arr[0]);
	printf("배열 arr의 두번째 요소 : %p\n", &arr[1]);
	printf("배열 arr의 세번째 요소 : %p\n", &arr[2]);

	//arr = &arr[1];

	return 0;
}
//*/

/*
	결론 유추

	-	타입이 int형인 배열이므로 각 배열 요소별 할당되는 메모리 공간은 4바이트이다.

	-	모든 배열요소는 메모리 공간에 나란히 할당된다.

	-	배열의 이름은 배열 시작 주소의 값을 의미한다.

	-	배열의 이름은 값의 저장이 불가능한 상수이다.


		비교 조건		|	포인터 변수		|	배열 이름		|
	-------------------------------------------------------------
		이름 존재유무	|		존재		|		존재		|
		관리 대상		|	메모리의 주소값	|	메모리의 주소값	|
		주소값 변경가능	|		가능		|		불가능		|
	-------------------------------------------------------------
*/
//======================================================





//======================================================
/*
2.	배열 이름의 포인터 형과 * 연산.

	-	int arr[5];

		배열의 이름은 배열의 첫번째 요소를 가리키는 포인터이므로

		arr은 Int형 포인터라고 볼 수 있다.

*/

/*
int main(void)
{
	int arr1[3] = { 1,2,3 };
	double arr2[3] = { 1.1, 2.2, 3.3 };

	printf("*arr1 = %d,   *arr2 = %g\n", *arr1, *arr2);

	*arr1 += 100;
	*arr2 += 100.1;
	printf("*arr1 = %d,   *arr2 = %g\n", arr1[0], arr2[0]);

	return 0;
}
//*/
//======================================================




//======================================================
/*
3.	포인터의 배열 이름화.

	-	배열이름과 포인터 변수는 변수냐 상수냐의 특성적 차이만 있을뿐

		둘다 포인터.

		->	포인터 변수로 할수있는 연산은 배열이름으로도 할수 있고,

			배열 이름으로 할수 있는 연산은 포인터 변수로도 가능하다.
*/


/*
int main(void)
{
	int arr[3] = { 1,2,3 };
	int* ptr = arr;	//	int* ptr = &arr[0];

	printf("%d,   %d\n", ptr[0], arr[0]);
	printf("%d,   %d\n", ptr[1], arr[1]);
	printf("%d,   %d\n", ptr[2], arr[2]);

	printf("%d,   %d\n", *ptr, *arr);

	return 0;
}
//*/
//======================================================
