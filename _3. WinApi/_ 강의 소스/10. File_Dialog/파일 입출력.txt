/// 파일 입출력 /////////////////////////////////////////////////////////////////////
------------
0.	파일 액세스
------------
	1.	파일 액세스 3단계
		-	파일 열기	->	파일 액세스(읽기, 쓰기)	->	파일 닫기.
		-	fopen, fread / fwrite, fclose 와 유사.

	2.	파일 열기
		HANDLE CreateFile(	
							LPCSTR lpFileName,							//	열거나 생성하고자 하는 파일 경로.
							DWORD dwDesiredAccess,						//	파일 액세스 타입.
							DWORD dwShareMode,							//	열려진 파일의 공유 모드.
							LPSECURITY_ATTRIBUTES lpSecurityAttributes,	//	리턴된 핸들을 차일드 프로세스로 상속할 것인지 지정. 사용하지 않을경우 NULL.
							DWORD dwCreationDisposition,				//	만들고자 하는 파일이 이미 존해하는 경우 처리.
							DWORD dwFlagsAndAttributes,					//	파일의 속성과 옵션 설정.
							HANDLE hTemplateFile						//	새로 만들고자 하는 파일의 추가 속성 지원하는 템플릿 파일의 핸들 지정.
																			일반적으로 사용하지 않음. NULL.
							);											//	리턴값	:	파일 열기 성공시 핸들 반환.
																						실패시 INVALID_HANDLE_VALUE 반환.


		-------------------------------------------------------
		dwDesiredAccess			:	파일 액세스 타입.
		
			GENERIC_ALL				모든 엑세스 권한
			GENERIC_EXECUTE			실행 권한
			GENERIC_READ			읽기 권한
			GENERIC_WRITE			쓰기 권한
			DELETE					삭제 권한
			WRITE_OWNER				사용자의 쓰기 권한
			SYNCHRONIZE				동기화 권한
		-------------------------------------------------------
		dwShareMode				:	공유 모드 설정.
			0						모든 프로세스의 접근을 차단
			FILE_SHARE_READ			다른 프로세스의 열기 허가
			FILE_SHARE_WRITE		다른 프로세스의 쓰기 허가
			FILE_SHARE_DELETE		다른 프로세스의 삭제 허가
		-------------------------------------------------------
		dwCreationDisposition	:	만들고자 하는 파일이 이미 존해하는 경우 처리.

			CREATE_NEW				새로운 파일 생성. 지정 파일이 이미 있으면 만들지 않음.
			CREATE_ALWAYS			새로운 파일 생성. 지정 파일이 이미 있으면 삭제하고 생성.
			OPEN_EXISTING			파일이 존재할 때에만 파일 열기.
			OPEN_ALWAYS				파일이 존재하면 파일을 열고,
									파일이 존재하지 않으면 파일 생성
			TRUNCATE_EXISTING		파일을 열고 파일 크기를 0으로 만듬.
									GENERIC_WRITE 모드 필수.
		-------------------------------------------------------
		dwFlagsAndAttributes	:	파일의 속성과 옵션 설정.
			FILE_ATTRIBUTE_READONLY		읽기 전용.
			FILE_ATTRIBUTE_HIDDEN		숨은 파일.
			FILE_ATTRIBUTE_NORMAL		속성 없음.
										자주 사용됨.
										단독으로 사용해야 함.
			.......
		-------------------------------------------------------
		
	3.	파일 닫기
		BOOL CloseHandle( HANDLE hObject )
		:	파일 핸들도 메모리를 차지함.
			입출력을 위해 대량의 버퍼를 사용하므로 사용후 필히 해제.



------------
1.	파일 읽기.
------------
	1.	BOOL ReadFile(	HANDLE	hFile,					//	액세스할 핸들.
						LPVOID	lpBuffer,				//	얽으들인 데이터.
						DWORD	nNumberOfBytesToRead,	//	읽어올 데이터의 크기.
						LPDWORD lpNumberOfBytesRead,	//	실제 읽어드린 데이터의 크기
						LPOVERLAPPED lpOverlapped		//	비동기 입출력을 위한 OVERLAPPED 구조체의 포인터
														//	사용하지 않으면 NULL.
					);



------------
2.	파일 쓰기.
------------
	1.	BOOL WriteFile(	HANDLE hFile,					//	액세스할 핸들.
						LPVOID lpBuffer,				//	기록할 데이터.
						DWORD nNumberOfBytesToWrite,	//	기록할 데이터의 크기.
						LPDWORD lpNumberOfBytesWritten,	//	실제 기록한 데이터 크기.
						LPOVERLAPPED lpOverlapped		//	비동기 입출력을 위한 OVERLAPPED 구조체의 포인터
														//	사용하지 않으면 NULL.
						);



------------
3.	파일 공유.
------------
	1.	공유란?
		-	여러개의 프로그램이 한 파일을 동시에 액세스할 때 이미 열려진 파일을 다시 오픈하게 허락할 것인가를 지정하는 것.
		-	하나의 파일을 두 프로그램이 동시에 수정하는 경우 잠재적으로 데이터를 잃을 위험성이 발생.
		-	CreateFile함수의 dwShareMode로 설정.
		-	일반적으로 읽기 공유는 큰 문제가 없지만 쓰기 공유는 삼가할 것.

		dwShareMode				:	공유 모드 설정.
			0						모든 프로세스의 접근을 차단
			FILE_SHARE_READ			다른 프로세스의 열기 허가
			FILE_SHARE_WRITE		다른 프로세스의 쓰기 허가
			FILE_SHARE_DELETE		다른 프로세스의 삭제 허가

	2.	상용 프로그램의 실례...
		case 1:	메모장
				-	메모장으로 파일을 열어놓고 동일 파일을 다른 편집기로 열 수 있으며 편집 후 저장도 가능.
				-	메모장은 읽기와 쓰기 모두 공유 허가한 것처럼 판단가능.
					-	사실 공유에 대한 설정을 하지 않는다.
					-	대상 파일을 열고 클라이언트 영역에 읽어들인 내용을 출력후
						핸들을 바로 닫으므로 공유 설정이 불필요.
					-	필요한 경우에만 파일 액세스하며 오랫동안 파일을 독점하지 않는다.
					-	1. ReadFile 참고.
		case 2:	비쥬얼 스튜디오
				-	메모장과 유사.
				-	만약 편집중인 소스 파일을 독점해 버린다면
					소스 작성중 검색툴이나 (Ctrl + F)
					교체툴(Ctrl + H)등의 기능을 할 수 없다.
				-	대신 액티브 상태가 바뀔 때 외부에서 자신이 열어 놓은 파일을
					변경했는지 체크해보고 변경이 있었을 경우
					사용자에게 어떤 작업을 취할 것인지 물어봄으로써 공유로 인한 문제점을 해결.

		case 3: 액셀, 워드등..
				-	철저하게 공유를 설정하여 외부에서 접근하지 못하게 함.


